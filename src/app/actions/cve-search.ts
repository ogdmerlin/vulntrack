'use server'

const NIST_API_KEY = process.env.NIST_API_KEY
const NIST_BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

export interface CVESuggestion {
    cveId: string
    description: string
    severity: string
    cvssScore: number | null
}

export async function searchCVEs(query: string): Promise<{ success: boolean; data?: CVESuggestion[]; error?: string }> {
    if (!query || query.length < 4) {
        return { success: true, data: [] }
    }

    try {
        const headers: HeadersInit = {
            'Accept': 'application/json'
        }
        if (NIST_API_KEY) {
            headers['apiKey'] = NIST_API_KEY
        }

        // Check if it's a full CVE ID pattern
        const isCveId = /^CVE-\d{4}-\d+$/i.test(query)

        let url: string
        if (isCveId) {
            // Direct CVE lookup
            url = `${NIST_BASE_URL}?cveId=${query.toUpperCase()}`
        } else {
            // Keyword search - use partial match
            url = `${NIST_BASE_URL}?keywordSearch=${encodeURIComponent(query)}&resultsPerPage=10`
        }

        const response = await fetch(url, {
            headers,
            next: { revalidate: 300 } // Cache for 5 minutes
        })

        if (!response.ok) {
            if (response.status === 404) {
                return { success: true, data: [] }
            }
            console.error(`NIST API Error: ${response.status}`)
            return { success: false, error: `API Error: ${response.status}` }
        }

        const data = await response.json()
        const vulnerabilities = data.vulnerabilities || []

        const suggestions: CVESuggestion[] = vulnerabilities.slice(0, 8).map((vuln: any) => {
            const cve = vuln.cve
            const description = cve.descriptions?.find((d: any) => d.lang === 'en')?.value || "No description"

            // Extract CVSS
            const metrics = cve.metrics
            let cvssScore: number | null = null
            let severity = "UNKNOWN"

            if (metrics?.cvssMetricV31?.[0]) {
                cvssScore = metrics.cvssMetricV31[0].cvssData.baseScore
                severity = metrics.cvssMetricV31[0].cvssData.baseSeverity
            } else if (metrics?.cvssMetricV30?.[0]) {
                cvssScore = metrics.cvssMetricV30[0].cvssData.baseScore
                severity = metrics.cvssMetricV30[0].cvssData.baseSeverity
            } else if (metrics?.cvssMetricV2?.[0]) {
                cvssScore = metrics.cvssMetricV2[0].cvssData.baseScore
                severity = metrics.cvssMetricV2[0].baseSeverity || "UNKNOWN"
            }

            return {
                cveId: cve.id,
                description: description.length > 150 ? description.substring(0, 150) + "..." : description,
                severity,
                cvssScore
            }
        })

        return { success: true, data: suggestions }
    } catch (error) {
        console.error("Failed to search CVEs:", error)
        return { success: false, error: "Failed to search CVEs" }
    }
}
